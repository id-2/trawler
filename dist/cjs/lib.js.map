{"version":3,"file":"lib.js","sources":["../../src/common.js","../../src/lang.js","../../src/lang/latin/default.js","../../src/async.js","../../src/intersect.js","../../src/cache.js","../../src/index.js","../../src/document.js"],"sourcesContent":["export function parse_option(value, default_value){\n  return typeof value !== 'undefined' ? value : default_value;\n}\n\n/**\n * @param {!number} count\n * @returns {Array<Object>}\n */\n\nexport function create_object_array(count){\n  const array = new Array(count);\n\n  for(let i = 0; i < count; i++){\n    array[i] = create_object();\n  }\n\n  return array;\n}\n\nexport function create_arrays(count){\n  const array = new Array(count);\n\n  for(let i = 0; i < count; i++){\n    array[i] = [];\n  }\n\n  return array;\n}\n\n/**\n * @param {!Object} obj\n * @returns {Array<string>}\n */\n\nexport function get_keys(obj){\n  return Object.keys(obj);\n}\n\nexport function create_object(){\n  return Object.create(null);\n}\n\nexport function concat(arrays){\n  return [].concat.apply([], arrays);\n}\n\nexport function sort_by_length_down(a, b){\n  return b.length - a.length;\n}\n\nexport function is_array(val){\n  return val.constructor === Array;\n}\n\nexport function is_string(val){\n  return typeof val === 'string';\n}\n\nexport function is_object(val){\n  return typeof val === 'object';\n}\n\nexport function is_function(val){\n  return typeof val === 'function';\n}\n","import { create_object, get_keys } from './common.js';\n\n/**\n * @param {!string} str\n * @param {boolean|Array<string|RegExp>=} normalize\n * @param {boolean|string|RegExp=} split\n * @param {boolean=} _collapse\n * @returns {string|Array<string>}\n * @this IndexInterface\n */\n\nexport function pipeline(str, normalize, split, _collapse){\n  if(str){\n    if(normalize){\n      str = replace(str, /** @type {Array<string|RegExp>} */ (normalize));\n    }\n\n    if(this.matcher){\n      str = replace(str, this.matcher);\n    }\n\n    if(this.stemmer && (str.length > 1)){\n      str = replace(str, this.stemmer);\n    }\n\n    if(_collapse && (str.length > 1)){\n      str = collapse(str);\n    }\n\n    if(split || (split === '')){\n      const words = str.split(/** @type {string|RegExp} */ (split));\n\n      return this.filter ? filter(words, this.filter) : words;\n    }\n  }\n\n  return str;\n}\n\nexport const regex_whitespace = /[\\p{Z}\\p{S}\\p{P}\\p{C}]+/u;\nconst regex_normalize = /[\\u0300-\\u036f]/g;\n\nexport function normalize(str){\n  if(str.normalize){\n    str = str.normalize('NFD').replace(regex_normalize, '');\n  }\n\n  return str;\n}\n\n/**\n * @param {!string} str\n * @param {boolean|Array<string|RegExp>=} normalize\n * @param {boolean|string|RegExp=} split\n * @param {boolean=} _collapse\n * @returns {string|Array<string>}\n */\n\n// FlexSearch.prototype.pipeline = function(str, normalize, split, _collapse){\n//\n//     if(str){\n//\n//         if(normalize && str){\n//\n//             str = replace(str, /** @type {Array<string|RegExp>} */ (normalize));\n//         }\n//\n//         if(str && this.matcher){\n//\n//             str = replace(str, this.matcher);\n//         }\n//\n//         if(this.stemmer && str.length > 1){\n//\n//             str = replace(str, this.stemmer);\n//         }\n//\n//         if(_collapse && str.length > 1){\n//\n//             str = collapse(str);\n//         }\n//\n//         if(str){\n//\n//             if(split || (split === \"\")){\n//\n//                 const words = str.split(/** @type {string|RegExp} */ (split));\n//\n//                 return this.filter ? filter(words, this.filter) : words;\n//             }\n//         }\n//     }\n//\n//     return str;\n// };\n\n// export function pipeline(str, normalize, matcher, stemmer, split, _filter, _collapse){\n//\n//     if(str){\n//\n//         if(normalize && str){\n//\n//             str = replace(str, normalize);\n//         }\n//\n//         if(matcher && str){\n//\n//             str = replace(str, matcher);\n//         }\n//\n//         if(stemmer && str.length > 1){\n//\n//             str = replace(str, stemmer);\n//         }\n//\n//         if(_collapse && str.length > 1){\n//\n//             str = collapse(str);\n//         }\n//\n//         if(str){\n//\n//             if(split !== false){\n//\n//                 str = str.split(split);\n//\n//                 if(_filter){\n//\n//                     str = filter(str, _filter);\n//                 }\n//             }\n//         }\n//     }\n//\n//     return str;\n// }\n\n\n/**\n * @param {Array<string>} words\n * @returns {Object<string, string>}\n */\n\nexport function init_filter(words){\n  const filter = create_object();\n\n  for(let i = 0, length = words.length; i < length; i++){\n    filter[words[i]] = 1;\n  }\n\n  return filter;\n}\n\n/**\n * @param {!Object<string, string>} obj\n * @param {boolean} is_stemmer\n * @returns {Array}\n */\n\nexport function init_stemmer_or_matcher(obj, is_stemmer){\n  const keys = get_keys(obj);\n  const length = keys.length;\n  const final = [];\n\n  let removal = '', count = 0;\n\n  for(let i = 0, key, tmp; i < length; i++){\n    key = keys[i];\n    tmp = obj[key];\n\n    if(tmp){\n      final[count++] = regex(is_stemmer ? '(?!\\\\b)' + key + '(\\\\b|_)' : key);\n      final[count++] = tmp;\n    }\n    else{\n      removal += (removal ? '|' : '') + key;\n    }\n  }\n\n  if(removal){\n    final[count++] = regex(is_stemmer ? '(?!\\\\b)(' + removal + ')(\\\\b|_)' : '(' + removal + ')');\n    final[count] = '';\n  }\n\n  return final;\n}\n\n\n/**\n * @param {!string} str\n * @param {Array} regexp\n * @returns {string}\n */\n\nexport function replace(str, regexp){\n  for(let i = 0, len = regexp.length; i < len; i += 2){\n    str = str.replace(regexp[i], regexp[i + 1]);\n\n    if(!str){\n      break;\n    }\n  }\n\n  return str;\n}\n\n/**\n * @param {!string} str\n * @returns {RegExp}\n */\n\nexport function regex(str){\n  return new RegExp(str, 'g');\n}\n\n/**\n * Regex: replace(/(?:(\\w)(?:\\1)*)/g, \"$1\")\n * @param {!string} string\n * @returns {string}\n */\n\nexport function collapse(string){\n  let final = '', prev = '';\n\n  for(let i = 0, len = string.length, char; i < len; i++){\n    if((char = string[i]) !== prev){\n      final += (prev = char);\n    }\n  }\n\n  return final;\n}\n\n// TODO using fast-swap\nexport function filter(words, map){\n  const length = words.length;\n  const filtered = [];\n\n  for(let i = 0, count = 0; i < length; i++){\n    const word = words[i];\n\n    if(word && !map[word]){\n      filtered[count++] = word;\n    }\n  }\n\n  return filtered;\n}\n\n// const chars = {a:1, e:1, i:1, o:1, u:1, y:1};\n//\n// function collapse_repeating_chars(string){\n//\n//     let collapsed_string = \"\",\n//         char_prev = \"\",\n//         char_next = \"\";\n//\n//     for(let i = 0; i < string.length; i++){\n//\n//         const char = string[i];\n//\n//         if(char !== char_prev){\n//\n//             if(i && (char === \"h\")){\n//\n//                 if((chars[char_prev] && chars[char_next]) || (char_prev === \" \")){\n//\n//                     collapsed_string += char;\n//                 }\n//             }\n//             else{\n//\n//                 collapsed_string += char;\n//             }\n//         }\n//\n//         char_next = (\n//\n//             (i === (string.length - 1)) ?\n//\n//                 \"\"\n//             :\n//                 string[i + 1]\n//         );\n//\n//         char_prev = char;\n//     }\n//\n//     return collapsed_string;\n// }\n","import { pipeline, regex_whitespace } from '../../lang.js';\n\nexport const rtl = false;\nexport const tokenize = '';\nexport default {\n  encode: encode,\n  rtl: rtl,\n  tokenize: tokenize\n};\n\n/**\n * @this IndexInterface\n */\n\nexport function encode(str){\n  return pipeline.call(\n\n    this,\n    /* string: */ ('' + str).toLowerCase(),\n    /* normalize: */ false,\n    /* split: */ regex_whitespace,\n    /* collapse: */ false\n  );\n}\n","//import { promise as Promise } from \"./polyfill.js\";\nimport { is_function } from './common.js';\n\nexport default function(prototype){\n  register(prototype, 'add');\n  register(prototype, 'append');\n  register(prototype, 'search');\n  register(prototype, 'update');\n  register(prototype, 'remove');\n}\n\nfunction register(prototype, key){\n  prototype[key + 'Async'] = function(){\n    /** @type {IndexInterface|DocumentInterface} */\n    const self = this;\n    const args = /*[].slice.call*/(arguments);\n    const arg = args[args.length - 1];\n    let callback;\n\n    if(is_function(arg)){\n      callback = arg;\n      delete args[args.length - 1];\n    }\n\n    const promise = new Promise(function(resolve){\n      setTimeout(function(){\n        self.async = true;\n        const res = self[key].apply(self, args);\n        self.async = false;\n        resolve(res);\n      });\n    });\n\n    if(callback){\n      promise.then(callback);\n      return this;\n    }\n    else{\n      return promise;\n    }\n  };\n}\n","import { create_object } from './common.js';\n\n/**\n * Implementation based on Array.indexOf() provides better performance,\n * but it needs at least one word in the query which is less frequent.\n * Also on large indexes it does not scale well performance-wise.\n * This strategy also lacks of suggestion capabilities (matching & sorting).\n *\n * @param arrays\n * @param limit\n * @param offset\n * @param {boolean|Array=} suggest\n * @returns {Array}\n */\n\n// export function intersect(arrays, limit, offset, suggest) {\n//\n//     const length = arrays.length;\n//     let result = [];\n//     let check;\n//\n//     // determine shortest array and collect results\n//     // from the sparse relevance arrays\n//\n//     let smallest_size;\n//     let smallest_arr;\n//     let smallest_index;\n//\n//     for(let x = 0; x < length; x++){\n//\n//         const arr = arrays[x];\n//         const len = arr.length;\n//\n//         let size = 0;\n//\n//         for(let y = 0, tmp; y < len; y++){\n//\n//             tmp = arr[y];\n//\n//             if(tmp){\n//\n//                 size += tmp.length;\n//             }\n//         }\n//\n//         if(!smallest_size || (size < smallest_size)){\n//\n//             smallest_size = size;\n//             smallest_arr = arr;\n//             smallest_index = x;\n//         }\n//     }\n//\n//     smallest_arr = smallest_arr.length === 1 ?\n//\n//         smallest_arr[0]\n//     :\n//         concat(smallest_arr);\n//\n//     if(suggest){\n//\n//         suggest = [smallest_arr];\n//         check = create_object();\n//     }\n//\n//     let size = 0;\n//     let steps = 0;\n//\n//     // process terms in reversed order often results in better performance.\n//     // the outer loop must be the words array, using the\n//     // smallest array here disables the \"fast fail\" optimization.\n//\n//     for(let x = length - 1; x >= 0; x--){\n//\n//         if(x !== smallest_index){\n//\n//             steps++;\n//\n//             const word_arr = arrays[x];\n//             const word_arr_len = word_arr.length;\n//             const new_arr = [];\n//\n//             let count = 0;\n//\n//             for(let z = 0, id; z < smallest_arr.length; z++){\n//\n//                 id = smallest_arr[z];\n//\n//                 let found;\n//\n//                 // process relevance in forward order (direction is\n//                 // important for adding IDs during the last round)\n//\n//                 for(let y = 0; y < word_arr_len; y++){\n//\n//                     const arr = word_arr[y];\n//\n//                     if(arr.length){\n//\n//                         found = arr.indexOf(id) !== -1;\n//\n//                         if(found){\n//\n//                             // check if in last round\n//\n//                             if(steps === length - 1){\n//\n//                                 if(offset){\n//\n//                                     offset--;\n//                                 }\n//                                 else{\n//\n//                                     result[size++] = id;\n//\n//                                     if(size === limit){\n//\n//                                         // fast path \"end reached\"\n//\n//                                         return result;\n//                                     }\n//                                 }\n//\n//                                 if(suggest){\n//\n//                                     check[id] = 1;\n//                                 }\n//                             }\n//\n//                             break;\n//                         }\n//                     }\n//                 }\n//\n//                 if(found){\n//\n//                     new_arr[count++] = id;\n//                 }\n//             }\n//\n//             if(suggest){\n//\n//                 suggest[steps] = new_arr;\n//             }\n//             else if(!count){\n//\n//                 return [];\n//             }\n//\n//             smallest_arr = new_arr;\n//         }\n//     }\n//\n//     if(suggest){\n//\n//         // needs to iterate in reverse direction\n//\n//         for(let x = suggest.length - 1, arr, len; x >= 0; x--){\n//\n//             arr = suggest[x];\n//             len = arr && arr.length;\n//\n//             if(len){\n//\n//                 for(let y = 0, id; y < len; y++){\n//\n//                     id = arr[y];\n//\n//                     if(!check[id]){\n//\n//                         check[id] = 1;\n//\n//                         if(offset){\n//\n//                             offset--;\n//                         }\n//                         else{\n//\n//                             result[size++] = id;\n//\n//                             if(size === limit){\n//\n//                                 // fast path \"end reached\"\n//\n//                                 return result;\n//                             }\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//\n//     return result;\n// }\n\n/**\n * Implementation based on Object[key] provides better suggestions\n * capabilities and has less performance scaling issues on large indexes.\n *\n * @param arrays\n * @param limit\n * @param offset\n * @param {boolean|Array=} suggest\n * @returns {Array}\n */\n\nexport function intersect(arrays, limit, offset, suggest) {\n  const length = arrays.length;\n  let result = [];\n  let check;\n  let check_suggest;\n  let size = 0;\n\n  if(suggest){\n    suggest = [];\n  }\n\n  // process terms in reversed order often has advantage for the fast path \"end reached\".\n  // also a reversed order prioritize the order of words from a query.\n\n  for(let x = length - 1; x >= 0; x--){\n    const word_arr = arrays[x];\n    const word_arr_len = word_arr.length;\n    const check_new = create_object();\n\n    let found = !check;\n\n    // process relevance in forward order (direction is\n    // important for adding IDs during the last round)\n\n    for(let y = 0; y < word_arr_len; y++){\n      const arr = word_arr[y];\n      const arr_len = arr.length;\n\n      if(arr_len){\n        // loop through IDs\n\n        for(let z = 0, check_idx, id; z < arr_len; z++){\n          id = arr[z];\n\n          if(check){\n            if(check[id]){\n              // check if in last round\n\n              if(!x){\n                if(offset){\n                  offset--;\n                }\n                else{\n                  result[size++] = id;\n\n                  if(size === limit){\n                    // fast path \"end reached\"\n\n                    return result;\n                  }\n                }\n              }\n\n              if(x || suggest){\n                check_new[id] = 1;\n              }\n\n              found = true;\n            }\n\n            if(suggest){\n              check_idx = check_suggest[id];\n              check_suggest[id] = check_idx ? ++check_idx : check_idx = 1;\n\n              // do not adding IDs which are already included in the result (saves one loop)\n              // the first intersection match has the check index 2, so shift by -2\n\n              if(check_idx < length){\n                const tmp = suggest[check_idx - 2] || (suggest[check_idx - 2] = []);\n                tmp[tmp.length] = id;\n              }\n            }\n          }\n          else{\n            // pre-fill in first round\n\n            check_new[id] = 1;\n          }\n        }\n      }\n    }\n\n    if(suggest){\n      // re-use the first pre-filled check for suggestions\n\n      check || (check_suggest = check_new);\n    }\n    else if(!found){\n      return [];\n    }\n\n    check = check_new;\n  }\n\n  if(suggest){\n    // needs to iterate in reverse direction\n\n    for(let x = suggest.length - 1, arr, len; x >= 0; x--){\n      arr = suggest[x];\n      len = arr.length;\n\n      for(let y = 0, id; y < len; y++){\n        id = arr[y];\n\n        if(!check[id]){\n          if(offset){\n            offset--;\n          }\n          else{\n            result[size++] = id;\n\n            if(size === limit){\n              // fast path \"end reached\"\n\n              return result;\n            }\n          }\n\n          check[id] = 1;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * @param mandatory\n * @param arrays\n * @returns {Array}\n */\n\nexport function intersect_union(mandatory, arrays) {\n  const check = create_object();\n  const union = create_object();\n  const result = [];\n\n  for(let x = 0; x < mandatory.length; x++){\n    check[mandatory[x]] = 1;\n  }\n\n  for(let x = 0, arr; x <  arrays.length; x++){\n    arr = arrays[x];\n\n    for(let y = 0, id; y < arr.length; y++){\n      id = arr[y];\n\n      if(check[id]){\n        if(!union[id]){\n          union[id] = 1;\n          result[result.length] = id;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n","import { create_object, is_object } from './common.js';\n\n/**\n * @param {boolean|number=} limit\n * @constructor\n */\n\nfunction CacheClass(limit){\n  /** @private */\n  this.limit = (limit !== true) && limit;\n\n  /** @private */\n  this.cache = create_object();\n\n  /** @private */\n  this.queue = [];\n\n  //this.clear();\n}\n\nexport default CacheClass;\n\n/**\n * @param {string|Object} query\n * @param {number|Object=} limit\n * @param {Object=} options\n * @this {IndexInterface}\n * @returns {Array<number|string>}\n */\n\nexport function searchCache(query, limit, options){\n  if(is_object(query)){\n    query = query.query;\n  }\n\n  let cache = this.cache.get(query);\n\n  if(!cache){\n    cache = this.search(query, limit, options);\n    this.cache.set(query, cache);\n  }\n\n  return cache;\n}\n\n// CacheClass.prototype.clear = function(){\n//\n//     /** @private */\n//     this.cache = create_object();\n//\n//     /** @private */\n//     this.queue = [];\n// };\n\nCacheClass.prototype.set = function(key, value){\n  if(!this.cache[key]){\n    // it is just a shame that native function array.shift() performs so bad\n\n    // const length = this.queue.length;\n    //\n    // this.queue[length] = key;\n    //\n    // if(length === this.limit){\n    //\n    //     delete this.cache[this.queue.shift()];\n    // }\n\n    // the same bad performance\n\n    // this.queue.unshift(key);\n    //\n    // if(this.queue.length === this.limit){\n    //\n    //     this.queue.pop();\n    // }\n\n    // fast implementation variant\n\n    // let length = this.queue.length;\n    //\n    // if(length === this.limit){\n    //\n    //     length--;\n    //\n    //     delete this.cache[this.queue[0]];\n    //\n    //     for(let x = 0; x < length; x++){\n    //\n    //         this.queue[x] = this.queue[x + 1];\n    //     }\n    // }\n    //\n    // this.queue[length] = key;\n\n    // current fastest implementation variant\n    // theoretically that should not perform better compared to the example above\n\n    let length = this.queue.length;\n\n    if(length === this.limit){\n      delete this.cache[this.queue[length - 1]];\n    }\n    else{\n      length++;\n    }\n\n    for(let x = length - 1; x > 0; x--){\n      this.queue[x] = this.queue[x - 1];\n    }\n\n    this.queue[0] = key;\n  }\n\n  this.cache[key] = value;\n};\n\nCacheClass.prototype.get = function(key){\n  const cache = this.cache[key];\n\n  if(this.limit && cache){\n    // probably the indexOf() method performs faster when matched content is on front (left-to-right)\n    // using lastIndexOf() does not help, it performs almost slower\n\n    const pos = this.queue.indexOf(key);\n\n    // if(pos < this.queue.length - 1){\n    //\n    //     const tmp = this.queue[pos];\n    //     this.queue[pos] = this.queue[pos + 1];\n    //     this.queue[pos + 1] = tmp;\n    // }\n\n    if(pos){\n      const tmp = this.queue[pos - 1];\n      this.queue[pos - 1] = this.queue[pos];\n      this.queue[pos] = tmp;\n    }\n  }\n\n  return cache;\n};\n\nCacheClass.prototype.del = function(id){\n  for(let i = 0, item, key; i < this.queue.length; i++){\n    key = this.queue[i];\n    item = this.cache[key];\n\n    if(item.indexOf(id) !== -1){\n      this.queue.splice(i--, 1);\n      delete this.cache[key];\n    }\n  }\n};\n","/**!\n * FlexSearch.js\n * Copyright 2018-2021 Nextapps GmbH\n * Author: Thomas Wilkerling\n * Licence: Apache-2.0\n * https://github.com/nextapps-de/flexsearch\n */\n\nimport { encode as default_encoder } from './lang/latin/default.js';\nimport { create_object, create_object_array, concat, sort_by_length_down, is_array, is_object, parse_option } from './common.js';\nimport { init_stemmer_or_matcher, init_filter } from './lang.js';\nimport apply_async from './async.js';\nimport { intersect } from './intersect.js';\nimport Cache, { searchCache } from './cache.js';\n\n/**\n * @constructor\n * @param {Object=} options\n * @return {Index}\n */\n\nexport class Index {\n  constructor(options = {}) {\n    this.encode = default_encoder;\n    this.register = create_object();\n    this.resolution = options.resolution || 9;\n    this.tokenize = options.tokenize || 'strict';\n    this.depth = options?.context?.depth;\n    this.bidirectional = parse_option(options?.context?.bidirectional, true);\n    this.optimize = parse_option(options.optimize, true);\n    this.minlength = options.minlength || 1;\n    this.boost = options.boost;\n\n    // when not using the memory strategy the score array should not pre-allocated to its full length\n    this.map = this.optimize ? create_object_array(options?.context?.resolution || 9) : create_object();\n    this.resolution_ctx = options?.context?.resolution || 1;\n    this.ctx = this.optimize ? create_object_array(options?.context?.resolution || 1) : create_object();\n    this.rtl = options.rtl;\n    this.matcher = options.matcher && init_stemmer_or_matcher(options.matcher, false);\n    this.stemmer = options.stemmer && init_stemmer_or_matcher(options.stemmer, true);\n    this.filter = options.filter && init_filter(options.filter);\n    this.cache = options.cache && new Cache(options.cache);\n  }\n  //Index.prototype.pipeline = pipeline;\n  /**\n   * @param {!number|string} id\n   * @param {!string} content\n   */\n  append(id, content) {\n    return this.add(id, content, true);\n  }\n  /**\n   * @param {!number|string} id\n   * @param {!string} content\n   * @param {boolean=} _append\n   * @param {boolean=} _skip_update\n   */\n  add(id, content, _append, _skip_update) {\n    if (content && (id || (id === 0))) {\n      if (!_skip_update && !_append && this.register[id]) {\n        return this.update(id, content);\n      }\n\n      content = this.encode(content);\n      const length = content.length;\n\n      if (length) {\n        // check context dupes to skip all contextual redundancy along a document\n        const dupes_ctx = create_object();\n        const dupes = create_object();\n        const depth = this.depth;\n        const resolution = this.resolution;\n\n        for (let i = 0; i < length; i++) {\n          let term = content[this.rtl ? length - 1 - i : i];\n          let term_length = term.length;\n\n          // skip dupes will break the context chain\n          if (term && (term_length >= this.minlength) && (depth || !dupes[term])) {\n            let score = get_score(resolution, length, i);\n            let token = '';\n\n            switch (this.tokenize) {\n            case 'full':\n\n              if (term_length > 3) {\n                for (let x = 0; x < term_length; x++) {\n                  for (let y = term_length; y > x; y--) {\n                    if ((y - x) >= this.minlength) {\n                      const partial_score = get_score(resolution, length, i, term_length, x);\n                      token = term.substring(x, y);\n                      this.push_index(dupes, token, partial_score, id, _append);\n                    }\n                  }\n                }\n\n                break;\n              }\n\n              // fallthrough to next case when term length < 4\n            case 'reverse':\n\n              // skip last round (this token exist already in \"forward\")\n              if (term_length > 2) {\n                for (let x = term_length - 1; x > 0; x--) {\n                  token = term[x] + token;\n\n                  if (token.length >= this.minlength) {\n                    const partial_score = get_score(resolution, length, i, term_length, x);\n                    this.push_index(dupes, token, partial_score, id, _append);\n                  }\n                }\n\n                token = '';\n              }\n\n              // fallthrough to next case to apply forward also\n            case 'forward':\n\n              if (term_length > 1) {\n                for (let x = 0; x < term_length; x++) {\n                  token += term[x];\n\n                  if (token.length >= this.minlength) {\n                    this.push_index(dupes, token, score, id, _append);\n                  }\n                }\n\n                break;\n              }\n\n              // fallthrough to next case when token has a length of 1\n            default:\n              // case \"strict\":\n              if (this.boost) {\n                score = Math.min((score / this.boost(content, term, i)) | 0, resolution - 1);\n              }\n\n              this.push_index(dupes, term, score, id, _append);\n\n              // context is just supported by tokenizer \"strict\"\n              if (depth) {\n                if ((length > 1) && (i < (length - 1))) {\n                  // check inner dupes to skip repeating words in the current context\n                  const dupes_inner = create_object();\n                  const resolution = this.resolution_ctx;\n                  const keyword = term;\n                  const size = Math.min(depth + 1, length - i);\n\n                  dupes_inner[keyword] = 1;\n\n                  for (let x = 1; x < size; x++) {\n                    term = content[this.rtl ? length - 1 - i - x : i + x];\n\n                    if (term && (term.length >= this.minlength) && !dupes_inner[term]) {\n                      dupes_inner[term] = 1;\n\n                      const context_score = get_score(resolution + ((length / 2) > resolution ? 0 : 1), length, i, size - 1, x - 1);\n                      const swap = this.bidirectional && (term > keyword);\n                      this.push_index(dupes_ctx, swap ? keyword : term, context_score, id, _append, swap ? term : keyword);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * @private\n   * @param dupes\n   * @param value\n   * @param score\n   * @param id\n   * @param {boolean=} append\n   * @param {string=} keyword\n   */\n  push_index(dupes, value, score, id, append, keyword) {\n    let arr = keyword ? this.ctx : this.map;\n\n    if (!dupes[value] || (keyword && !dupes[value][keyword])) {\n      if (this.optimize) {\n        arr = arr[score];\n      }\n\n      if (keyword) {\n        dupes = dupes[value] || (dupes[value] = create_object());\n        dupes[keyword] = 1;\n\n        arr = arr[keyword] || (arr[keyword] = create_object());\n      }\n      else {\n        dupes[value] = 1;\n      }\n\n      arr = arr[value] || (arr[value] = []);\n\n      if (!this.optimize) {\n        arr = arr[score] || (arr[score] = []);\n      }\n\n      if (!append || (arr.indexOf(id) === -1)) {\n        arr[arr.length] = id;\n        this.register[id] ||= [];\n        this.register[id].push(arr);\n      }\n    }\n  }\n  /**\n   * @param {string|Object} query\n   * @param {number|Object=} limit\n   * @param {Object=} options\n   * @returns {Array<number|string>}\n   */\n  search(query, limit, options) {\n    if (!options) {\n      if (!limit && is_object(query)) {\n        options = /** @type {Object} */ (query);\n        query = options.query;\n      }\n      else if (is_object(limit)) {\n        options = /** @type {Object} */ (limit);\n      }\n    }\n\n    let result = [];\n    let length;\n    let context, suggest, offset = 0;\n\n    if (options) {\n      limit = options.limit;\n      offset = options.offset || 0;\n      context = options.context;\n      suggest = options.suggest;\n    }\n\n    if (query) {\n      query = /** @type {Array} */ (this.encode(query));\n      length = query.length;\n\n      // TODO: solve this in one single loop below\n      if (length > 1) {\n        const dupes = create_object();\n        const query_new = [];\n\n        for (let i = 0, count = 0, term; i < length; i++) {\n          term = query[i];\n\n          if (term && (term.length >= this.minlength) && !dupes[term]) {\n            // this fast path just could applied when not in memory-optimized mode\n            if (!this.optimize && !suggest && !this.map[term]) {\n              // fast path \"not found\"\n              return result;\n            }\n            else {\n              query_new[count++] = term;\n              dupes[term] = 1;\n            }\n          }\n        }\n\n        query = query_new;\n        length = query.length;\n      }\n    }\n\n    if (!length) {\n      return result;\n    }\n\n    limit || (limit = 100);\n\n    let depth = this.depth && (length > 1) && (context !== false);\n    let index = 0, keyword;\n\n    if (depth) {\n      keyword = query[0];\n      index = 1;\n    }\n    else {\n      if (length > 1) {\n        query.sort(sort_by_length_down);\n      }\n    }\n\n    for (let arr, term; index < length; index++) {\n      term = query[index];\n\n      // console.log(keyword);\n      // console.log(term);\n      // console.log(\"\");\n      if (depth) {\n        arr = this.add_result(result, suggest, limit, offset, length === 2, term, keyword);\n\n        // console.log(arr);\n        // console.log(result);\n        // when suggestion enabled just forward keyword if term was found\n        // as long as the result is empty forward the pointer also\n        if (!suggest || (arr !== false) || !result.length) {\n          keyword = term;\n        }\n      }\n      else {\n        arr = this.add_result(result, suggest, limit, offset, length === 1, term);\n      }\n\n      if (arr) {\n        return /** @type {Array<number|string>} */ (arr);\n      }\n\n      // apply suggestions on last loop or fallback\n      if (suggest && (index === length - 1)) {\n        let length = result.length;\n\n        if (!length) {\n          if (depth) {\n            // fallback to non-contextual search when no result was found\n            depth = 0;\n            index = -1;\n\n            continue;\n          }\n\n          return result;\n        }\n        else if (length === 1) {\n          // fast path optimization\n          return single_result(result[0], limit, offset);\n        }\n      }\n    }\n\n    return intersect(result, limit, offset, suggest);\n  }\n  /**\n   * Returns an array when the result is done (to stop the process immediately),\n   * returns false when suggestions is enabled and no result was found,\n   * or returns nothing when a set was pushed successfully to the results\n   *\n   * @private\n   * @param {Array} result\n   * @param {Array} suggest\n   * @param {number} limit\n   * @param {number} offset\n   * @param {boolean} single_term\n   * @param {string} term\n   * @param {string=} keyword\n   * @return {Array<Array<string|number>>|boolean|undefined}\n   */\n  add_result(result, suggest, limit, offset, single_term, term, keyword) {\n    let word_arr = [];\n    let arr = keyword ? this.ctx : this.map;\n\n    if (!this.optimize) {\n      arr = get_array(arr, term, keyword, this.bidirectional);\n    }\n\n    if (arr) {\n      let count = 0;\n      const arr_len = Math.min(arr.length, keyword ? this.resolution_ctx : this.resolution);\n\n      // relevance:\n      for (let x = 0, size = 0, tmp, len; x < arr_len; x++) {\n        tmp = arr[x];\n\n        if (tmp) {\n          if (this.optimize) {\n            tmp = get_array(tmp, term, keyword, this.bidirectional);\n          }\n\n          if (offset) {\n            if (tmp && single_term) {\n              len = tmp.length;\n\n              if (len <= offset) {\n                offset -= len;\n                tmp = null;\n              }\n              else {\n                tmp = tmp.slice(offset);\n                offset = 0;\n              }\n            }\n          }\n\n          if (tmp) {\n            // keep score (sparse array):\n            //word_arr[x] = tmp;\n            // simplified score order:\n            word_arr[count++] = tmp;\n\n            if (single_term) {\n              size += tmp.length;\n\n              if (size >= limit) {\n                // fast path optimization\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      if (count) {\n        if (single_term) {\n          // fast path optimization\n          // offset was already applied at this point\n          return single_result(word_arr, limit, 0);\n        }\n\n        result[result.length] = word_arr;\n        return;\n      }\n    }\n\n    // return an empty array will stop the loop,\n    // to prevent stop when using suggestions return a false value\n    return !suggest && word_arr;\n  }\n  contain(id) {\n    return !!this.register[id];\n  }\n  update(id, content) {\n    return this.remove(id).add(id, content);\n  }\n  /**\n   * @param {boolean=} _skip_deletion\n   */\n  remove(id, _skip_deletion) {\n    const refs = this.register[id];\n\n    if (refs) {\n      remove_index(this.map, id, this.resolution, this.optimize);\n\n      if (this.depth) {\n        remove_index(this.ctx, id, this.resolution_ctx, this.optimize);\n      }\n\n      _skip_deletion || delete this.register[id];\n\n      if (this.cache) {\n        this.cache.del(id);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Convert `this` into an exportable object\n   */\n  serialize() {\n    return {\n      reg: this.register,\n      opt: this.optimize,\n      map: this.map,\n      ctx: this.ctx,\n      tok: this.tokenize\n    };\n  }\n\n  /**\n   * Given a string load an Index object from it\n   * @param {string} str the serialized Index object\n   */\n  static deserialize(obj, params) {\n    // TODO add extra parameter for index initialization?\n    const result = new Index(params);\n    result.optimize = obj.opt;\n    result.register = obj.reg;\n    result.map      = obj.map;\n    result.ctx      = obj.ctx;\n    result.tokenize = obj.tok;\n    return result;\n  }\n}\n\n\n\n/**\n * @param {number} resolution\n * @param {number} length\n * @param {number} i\n * @param {number=} term_length\n * @param {number=} x\n * @returns {number}\n */\n\nfunction get_score(resolution, length, i, term_length, x){\n  // console.log(\"resolution\", resolution);\n  // console.log(\"length\", length);\n  // console.log(\"term_length\", term_length);\n  // console.log(\"i\", i);\n  // console.log(\"x\", x);\n  // console.log((resolution - 1) / (length + (term_length || 0)) * (i + (x || 0)) + 1);\n\n  // the first resolution slot is reserved for the best match,\n  // when a query matches the first word(s).\n\n  // also to stretch score to the whole range of resolution, the\n  // calculation is shift by one and cut the floating point.\n  // this needs the resolution \"1\" to be handled additionally.\n\n  // do not stretch the resolution more than the term length will\n  // improve performance and memory, also it improves scoring in\n  // most cases between a short document and a long document\n\n  return i && (resolution > 1) ? (\n\n    (length + (term_length || 0)) <= resolution ?\n\n      i + (x || 0)\n      :\n      ((resolution - 1) / (length + (term_length || 0)) * (i + (x || 0)) + 1) | 0\n  ):\n    0;\n}\n\n\n\n\nfunction single_result(result, limit, offset){\n  if(result.length === 1){\n    result = result[0];\n  }\n  else{\n    result = concat(result);\n  }\n\n  return offset || (result.length > limit) ?\n\n    result.slice(offset, offset + limit)\n    :\n    result;\n}\n\nfunction get_array(arr, term, keyword, bidirectional){\n  if(keyword){\n    // the frequency of the starting letter is slightly less\n    // on the last half of the alphabet (m-z) in almost every latin language,\n    // so we sort downwards (https://en.wikipedia.org/wiki/Letter_frequency)\n\n    const swap = bidirectional && (term > keyword);\n\n    arr = arr[swap ? term : keyword];\n    arr = arr && arr[swap ? keyword : term];\n  }\n  else{\n    arr = arr[term];\n  }\n\n  return arr;\n}\n\n\n\n\n/**\n * @param map\n * @param id\n * @param res\n * @param optimize\n * @param {number=} resolution\n * @return {number}\n */\n\nfunction remove_index(map, id, res, optimize, resolution){\n  let count = 0;\n\n  if(is_array(map)){\n    // the first array is the score array in both strategies\n\n    if(!resolution){\n      resolution = Math.min(map.length, res);\n\n      for(let x = 0, arr; x < resolution; x++){\n        arr = map[x];\n\n        if(arr){\n          count = remove_index(arr, id, res, optimize, resolution);\n\n          if(!optimize && !count){\n            // when not memory optimized the score index should removed\n\n            delete map[x];\n          }\n        }\n      }\n    }\n    else{\n      const pos = map.indexOf(id);\n\n      if(pos !== -1){\n        // fast path, when length is 1 or lower then the whole field gets deleted\n\n        if(map.length > 1){\n          map.splice(pos, 1);\n          count++;\n        }\n      }\n      else{\n        count++;\n      }\n    }\n  }\n  else{\n    for(let key in map){\n      count = remove_index(map[key], id, res, optimize, resolution);\n\n      if(!count){\n        delete map[key];\n      }\n    }\n  }\n\n  return count;\n}\n\n// TODO bring all these functions into this file\nIndex.prototype.searchCache = searchCache;\napply_async(Index.prototype);\n","/**!\n * FlexSearch.js\n * Copyright 2018-2021 Nextapps GmbH\n * Author: Thomas Wilkerling\n * Licence: Apache-2.0\n * https://github.com/nextapps-de/flexsearch\n */\n\nimport { Index } from './index.js';\nimport Cache, { searchCache } from './cache.js';\nimport { create_object, is_array, is_string, is_object } from './common.js';\nimport apply_async from './async.js';\nimport { intersect, intersect_union } from './intersect.js';\n\n/**\n * @constructor\n * @implements DocumentInterface\n * @param {Object=} options\n * @return {Document}\n */\n\nexport class Document {\n  constructor(options) {\n    const document = options.document || options.doc || options;\n    let opt;\n\n    this.tree = [];\n    this.field = [];\n    this.marker = [];\n    this.register = create_object();\n    this.key = ((opt = document.key || document.id) && parse_tree(opt, this.marker)) || 'id';\n\n    this.storetree = (opt = document.store) && (opt !== true) && [];\n    this.store = opt && create_object();\n\n    this.tag = ((opt = document.tag) && parse_tree(opt, this.marker));\n    this.tagindex = opt && create_object();\n\n    this.cache = (opt = options.cache) && new Cache(opt);\n\n    // do not apply cache again for the indexes\n    options.cache = false;\n\n    this.worker = options.worker;\n\n    // this switch is used by recall of promise callbacks\n    this.async = false;\n\n    this.index = this.parse_descriptor(options, document);\n  }\n\n  /**\n   *\n   * @param id\n   * @param content\n   * @param {boolean=} _append\n   * @returns {Document|Promise}\n   */\n  add(id, content, _append) {\n    if (is_object(id)) {\n      content = id;\n      id = parse_simple(content, this.key);\n    }\n\n    if (content && (id || (id === 0))) {\n      if (!_append && this.register[id]) {\n        return this.update(id, content);\n      }\n\n      for (let i = 0, tree, field; i < this.field.length; i++) {\n        field = this.field[i];\n        tree = this.tree[i];\n\n        if (is_string(tree)) {\n          tree = [tree];\n        }\n\n        add_index(content, tree, this.marker, 0, this.index[field], id, tree[0], _append);\n      }\n\n      if (this.tag) {\n        let tag = parse_simple(content, this.tag);\n        let dupes = create_object();\n\n        if (is_string(tag)) {\n          tag = [tag];\n        }\n\n        for (let i = 0, key, arr; i < tag.length; i++) {\n          key = tag[i];\n\n          if (!dupes[key]) {\n            dupes[key] = 1;\n            arr = this.tagindex[key] || (this.tagindex[key] = []);\n\n            if (!_append || (arr.indexOf(id) === -1)) {\n              arr[arr.length] = id;\n            }\n          }\n        }\n      }\n\n      // TODO: how to handle store when appending contents?\n      if (this.store && (!_append || !this.store[id])) {\n        let store;\n\n        if (this.storetree) {\n          store = create_object();\n\n          for (let i = 0, tree; i < this.storetree.length; i++) {\n            tree = this.storetree[i];\n\n            if (is_string(tree)) {\n              store[tree] = content[tree];\n            }\n            else {\n              store_value(content, store, tree, 0, tree[0]);\n            }\n          }\n        }\n\n        this.store[id] = store || content;\n      }\n    }\n\n    return this;\n  }\n  append(id, content) {\n    return this.add(id, content, true);\n  }\n  update(id, content) {\n    return this.remove(id).add(id, content);\n  }\n  remove(id) {\n    if (is_object(id)) {\n      id = parse_simple(id, this.key);\n    }\n\n    if (this.register[id]) {\n      for (let i = 0; i < this.field.length; i++) {\n        // workers does not share the register\n        this.index[this.field[i]].remove(id, !this.worker);\n      }\n\n      if (this.tag) {\n        for (let key in this.tagindex) {\n          const tag = this.tagindex[key];\n          const pos = tag.indexOf(id);\n\n          if (pos !== -1) {\n            if (tag.length > 1) {\n              tag.splice(pos, 1);\n            }\n            else {\n              delete this.tagindex[key];\n            }\n          }\n        }\n      }\n\n      if (this.store) {\n        delete this.store[id];\n      }\n\n      delete this.register[id];\n    }\n\n    return this;\n  }\n  /**\n   * @param {!string|Object} query\n   * @param {number|Object=} limit\n   * @param {Object=} options\n   * @param {Array<Array>=} _resolve For internal use only.\n   * @returns {Promise|Array}\n   */\n  search(query, limit, options, _resolve) {\n    if (!options) {\n      if (!limit && is_object(query)) {\n        options = /** @type {Object} */ (query);\n        query = options.query;\n      }\n      else if (is_object(limit)) {\n        options = /** @type {Object} */ (limit);\n        limit = 0;\n      }\n    }\n\n    let result = [], result_field = [];\n    let pluck, enrich;\n    let field, tag, bool, offset, count = 0;\n\n    if (options) {\n      if (is_array(options)) {\n        field = options;\n        options = null;\n      }\n      else {\n        pluck = options.pluck;\n        field = pluck || options.index || options.field /*|| (is_string(options) && [options])*/;\n        tag = options.tag;\n        enrich = this.store && options.enrich;\n        bool = options.bool === 'and';\n        limit = options.limit || 100;\n        offset = options.offset || 0;\n\n        if (tag) {\n          if (is_string(tag)) {\n            tag = [tag];\n          }\n\n          // when tags is used and no query was set,\n          // then just return the tag indexes\n          if (!query) {\n            for (let i = 0, res; i < tag.length; i++) {\n              res = get_tag.call(this, tag[i], limit, offset, enrich);\n\n              if (res) {\n                result[result.length] = res;\n                count++;\n              }\n            }\n\n            return count ? result : [];\n          }\n        }\n\n        if (is_string(field)) {\n          field = [field];\n        }\n      }\n    }\n\n    field || (field = this.field);\n    bool = bool && ((field.length > 1) || (tag && (tag.length > 1)));\n\n    const promises = !_resolve && (this.worker || this.async) && [];\n\n    // TODO solve this in one loop below\n    for (let i = 0, res, key, len; i < field.length; i++) {\n      let opt;\n\n      key = field[i];\n\n      if (!is_string(key)) {\n        opt = key;\n        key = key.field;\n      }\n\n      if (promises) {\n        promises[i] = this.index[key].searchAsync(query, limit, opt || options);\n\n        // just collect and continue\n        continue;\n      }\n      else if (_resolve) {\n        res = _resolve[i];\n      }\n      else {\n        // inherit options also when search? it is just for laziness, Object.assign() has a cost\n        res = this.index[key].search(query, limit, opt || options);\n      }\n\n      len = res && res.length;\n\n      if (tag && len) {\n        const arr = [];\n        let count = 0;\n\n        if (bool) {\n          // prepare for intersection\n          arr[0] = [res];\n        }\n\n        for (let y = 0, key, res; y < tag.length; y++) {\n          key = tag[y];\n          res = this.tagindex[key];\n          len = res && res.length;\n\n          if (len) {\n            count++;\n            arr[arr.length] = bool ? [res] : res;\n          }\n        }\n\n        if (count) {\n          if (bool) {\n            res = intersect(arr, limit || 100, offset || 0);\n          }\n          else {\n            res = intersect_union(res, arr);\n          }\n\n          len = res.length;\n        }\n      }\n\n      if (len) {\n        result_field[count] = key;\n        result[count++] = res;\n      }\n      else if (bool) {\n        return [];\n      }\n    }\n\n    if (promises) {\n      const self = this;\n\n      // anyone knows a better workaround of optionally having async promises?\n      // the promise.all() needs to be wrapped into additional promise,\n      // otherwise the recursive callback wouldn't run before return\n      return new Promise(function (resolve) {\n        Promise.all(promises).then(function (result) {\n          resolve(self.search(query, limit, options, result));\n        });\n      });\n    }\n\n    if (!count) {\n      // fast path \"not found\"\n      return [];\n    }\n\n    if (pluck && (!enrich || !this.store)) {\n      // fast path optimization\n      return result[0];\n    }\n\n    for (let i = 0, res; i < result_field.length; i++) {\n      res = result[i];\n\n      if (res.length) {\n        if (enrich) {\n          res = apply_enrich.call(this, res);\n        }\n      }\n\n      if (pluck) {\n        return res;\n      }\n\n      result[i] = {\n        'field': result_field[i],\n        'result': res\n      };\n    }\n\n    return result;\n  }\n  contain(id) {\n    return !!this.register[id];\n  }\n  get(id) {\n    return this.store[id];\n  }\n  set(id, data) {\n    this.store[id] = data;\n    return this;\n  }\n\n  /**\n   * Serialize `this` into an exportable object\n   */\n  serialize() {\n    const result = {\n      tag:   this.tagIndex,\n      reg:   this.register,\n      store: this.store,\n      field: this.field,\n      index: {}\n    };\n    Object.entries(this.index).forEach(([key, index]) => {\n      result.index[key] = index.serialize();\n    });\n    return result;\n  }\n\n  /**\n   * Create a `Document` from a serialized object\n   */\n  static deserialize(obj, params) {\n    // TODO add properties here?\n    const result = new Document(params);\n    result.tagIndex = obj.tag;\n    result.register = obj.reg;\n    result.store    = obj.store;\n    result.field    = obj.field;\n    Object.entries(obj.index).forEach(([key, exportedIndex]) => {\n      result.index[key] = Index.deserialize(exportedIndex);\n      result.index[key].register = obj.reg;\n    });\n    return result;\n  }\n\n  // Helper methods\n\n  parse_descriptor(options, document) {\n    const index = create_object();\n    let field = document.index || document.field || document;\n\n    if (is_string(field)) {\n      field = [field];\n    }\n\n    for (let i = 0, key, opt; i < field.length; i++) {\n      key = field[i];\n\n      if (!is_string(key)) {\n        opt = key;\n        key = key.field;\n      }\n\n      opt = is_object(opt) ? Object.assign({}, options, opt) : options;\n\n      if (!this.worker) {\n        index[key] = new Index(opt);\n        index[key].register = this.register;\n      }\n\n      this.tree[i] = parse_tree(key, this.marker);\n      this.field[i] = key;\n    }\n\n    if (this.storetree) {\n      let store = document.store;\n\n      if (is_string(store)) {\n        store = [store];\n      }\n\n      for (let i = 0; i < store.length; i++) {\n        this.storetree[i] = parse_tree(store[i], this.marker);\n      }\n    }\n\n    return index;\n  }\n}\n\nfunction parse_tree(key, marker){\n  const tree = key.split(':');\n  let count = 0;\n\n  for(let i = 0; i < tree.length; i++){\n    key = tree[i];\n\n    if(key.indexOf('[]') >= 0){\n      key = key.substring(0, key.length - 2);\n\n      if(key){\n        marker[count] = true;\n      }\n    }\n\n    if(key){\n      tree[count++] = key;\n    }\n  }\n\n  if(count < tree.length){\n    tree.length = count;\n  }\n\n  return count > 1 ? tree : tree[0];\n}\n\nfunction parse_simple(obj, tree){\n  if(is_string(tree)){\n    obj = obj[tree];\n  }\n  else{\n    for(let i = 0; obj && (i < tree.length); i++){\n      obj = obj[tree[i]];\n    }\n  }\n\n  return obj;\n}\n\nfunction store_value(obj, store, tree, pos, key){\n  obj = obj[key];\n\n  // reached target field\n\n  if(pos === (tree.length - 1)){\n    // store target value\n\n    store[key] = obj;\n  }\n  else if(obj){\n    if(is_array(obj)){\n      store = store[key] = new Array(obj.length);\n\n      for(let i = 0; i < obj.length; i++){\n        // do not increase pos (an array is not a field)\n        store_value(obj, store, tree, pos, i);\n      }\n    }\n    else{\n      store = store[key] || (store[key] = create_object());\n      key = tree[++pos];\n\n      store_value(obj, store, tree, pos, key);\n    }\n  }\n}\n\nfunction add_index(obj, tree, marker, pos, index, id, key, _append){\n  obj = obj[key];\n\n  if(obj){\n    // reached target field\n\n    if(pos === (tree.length - 1)){\n      // handle target value\n\n      if(is_array(obj)){\n        // append array contents so each entry gets a new scoring context\n\n        if(marker[pos]){\n          for(let i = 0; i < obj.length; i++){\n            index.add(id, obj[i], /* append: */ true, /* skip update: */ true);\n          }\n\n          return;\n        }\n\n        // or join array contents and use one scoring context\n\n        obj = obj.join(' ');\n      }\n\n      index.add(id, obj, _append, /* skip_update: */ true);\n    }\n    else{\n      if(is_array(obj)){\n        for(let i = 0; i < obj.length; i++){\n          // do not increase index, an array is not a field\n\n          add_index(obj, tree, marker, pos, index, id, i, _append);\n        }\n      }\n      else{\n        key = tree[++pos];\n\n        add_index(obj, tree, marker, pos, index, id, key, _append);\n      }\n    }\n  }\n}\n\n\n\n\n\n\n/**\n * @this Document\n */\n\nfunction get_tag(key, limit, offset, enrich){\n  let res = this.tagindex[key];\n  let len = res && (res.length - offset);\n\n  if(len && (len > 0)){\n    if((len > limit) || offset){\n      res = res.slice(offset, offset + limit);\n    }\n\n    if(enrich){\n      res = apply_enrich.call(this, res);\n    }\n\n    return {\n\n      'tag': key,\n      'result': res\n    };\n  }\n}\n\n/**\n * @this Document\n */\n\nfunction apply_enrich(res){\n  const arr = new Array(res.length);\n\n  for(let x = 0, id; x < res.length; x++){\n    id = res[x];\n\n    arr[x] = {\n\n      'id': id,\n      'doc': this.store[id]\n    };\n  }\n\n  return arr;\n}\n\n// TODO move all of this into this file\nDocument.prototype.searchCache = searchCache;\napply_async(Document.prototype);\n"],"names":["parse_option","value","default_value","create_object_array","count","array","Array","i","create_object","get_keys","obj","Object","keys","create","concat","arrays","apply","sort_by_length_down","a","b","length","is_array","val","constructor","is_string","is_object","is_function","pipeline","str","normalize","split","_collapse","replace","matcher","stemmer","collapse","words","filter","regex_whitespace","init_filter","init_stemmer_or_matcher","is_stemmer","final","removal","key","tmp","regex","regexp","len","RegExp","string","prev","char","map","filtered","word","encode","call","toLowerCase","prototype","register","self","args","arguments","arg","callback","promise","Promise","resolve","setTimeout","async","res","then","intersect","limit","offset","suggest","result","check","check_suggest","size","x","word_arr","word_arr_len","check_new","found","y","arr","arr_len","z","check_idx","id","intersect_union","mandatory","union","CacheClass","cache","queue","searchCache","query","options","get","search","set","pos","indexOf","del","item","splice","Index","default_encoder","resolution","tokenize","depth","context","bidirectional","optimize","minlength","boost","resolution_ctx","ctx","rtl","Cache","content","add","_append","_skip_update","update","dupes_ctx","dupes","term","term_length","score","get_score","token","partial_score","substring","push_index","Math","min","dupes_inner","keyword","context_score","swap","append","push","query_new","index","sort","add_result","single_result","single_term","get_array","slice","remove","_skip_deletion","refs","remove_index","reg","opt","tok","params","apply_async","Document","document","doc","tree","field","marker","parse_tree","storetree","store","tag","tagindex","worker","parse_descriptor","parse_simple","add_index","store_value","_resolve","result_field","pluck","enrich","bool","get_tag","promises","searchAsync","all","apply_enrich","data","tagIndex","entries","forEach","serialize","assign","exportedIndex","deserialize","join"],"mappings":"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AAiB;AAC3CC,MAAAA,UAAU,CAAC,YAAU;AACnBR,QAAAA,IAAI,CAACS,KAAL,GAAa,IAAb;AACA,YAAMC,GAAG,GAAGV,IAAI,CAACjB,GAAD,CAAJ,CAAU5B,KAAV,CAAgB6C,IAAhB,EAAsBC,IAAtB,CAAZ;AACAD,QAAAA,IAAI,CAACS,KAAL,GAAa,KAAb;AACAF,QAAAA,OAAO,CAACG,GAAD,CAAP;AACD,OALS,CAAV;AAMD,KAPe,CAAhB;;AASA,QAAGN,QAAH,EAAY;AACVC,MAAAA,OAAO,CAACM,IAAR,CAAaP,QAAb;AACA,aAAO,IAAP;AACD,KAHD,MAII;AACF,aAAOC,OAAP;AACD;AACF,GA5BD;AA6BD;;ACvCD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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"}